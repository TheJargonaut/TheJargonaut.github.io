<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordSense Corp.</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>WordSense</h1>
    <div>
        <button id="recordingButton" onclick="toggleRecording()">ðŸŽ™ Start Recording</button>
        <button id="notifyButton" onclick="sendNotification()" disabled>Notify</button>
        <button id="toggleTranscription" onclick="toggleTranscription()">Show Transcription</button>
        <button id="realTimeNotifyButton" onclick="toggleRealTimeNotifications()" disabled>Real-time Notify</button>
        <button id="showDialogButton">What's WordSense?</button>
    </div>
    <div id="sliderContainer">
        <input type="range" min="1" max="5" value="3" class="slider" id="myRange">
        <p id="proficiencyLevel">Current Frequency Threshold: 3</p>
    </div>
    <div id="dialogBox" class="hidden">
        <span id="closeButton" class="close-button">x</span>
        <div class="header">About WordSense</div>
        <div class="body">
            <span id="text"></span><span class="cursor"></span>
        </div>
    </div>
    <div id="results" style="display:none;"></div>
    <ul id="definition"></ul>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            if (Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        });

        // Initialize variables
        let recognition;
        let isRecording = false;
        let realTimeNotify = false;
        let lastWordTimestamp = 0;
        let definedWords = new Set();
        let wordBuffer = [];

        let frequencyThreshold = 3; // Initial threshold value

        // Update frequency threshold based on slider value
        document.getElementById("myRange").addEventListener("input", function () {
            frequencyThreshold = parseInt(this.value);
            updateProficiency();
        });

        // Function to update proficiency level
        function updateProficiency() {
            document.getElementById("proficiencyLevel").textContent = "Current Frequency Threshold: " + frequencyThreshold;
        }
        updateProficiency(); // Set initial value

        // Function definitions
        function stripPunctuation(word) {
            return word.toLowerCase().replace(/[\W_]+/g, "");
        }

        function toggleTranscription() {
            const resultsDiv = document.getElementById('results');
            const isHidden = resultsDiv.style.display === 'none';
            resultsDiv.style.display = isHidden ? 'block' : 'none';
            document.getElementById('toggleTranscription').textContent = isHidden ? 'Hide Transcription' : 'Show Transcription';
        }

        async function toggleRecording() {
            if (isRecording) {
                recognition.stop();
                document.getElementById("recordingButton").textContent = "ðŸŽ™ Start Recording";
            } else {
                await startListening();
                document.getElementById("recordingButton").textContent = "ðŸŽ™ Stop Recording";
            }
            isRecording = !isRecording;
        }

        document.addEventListener('DOMContentLoaded', function () {
            const showDialogButton = document.getElementById('showDialogButton');
            const dialogBox = document.getElementById('dialogBox');
            const closeButton = document.getElementById('closeButton');
            const textElement = document.getElementById('text');

            // Define the text to be typed
            const text = 'Ever been in a meeting or interview with a pompous old prig who thinks he invented the English language? We all know that guy. "Despite the epistemological quandaries presented by the dichotomy between constructivist ontology and positivist empiricism, the confluence of post-structuralist theories and quantum mechanics beckons scholars to reevaluate the hermeneutic frameworks that underpin our understanding of intersubjective reality." What did he say? You might have just lost the job because of a pretentious wannabe Brit. And whipping out your phone to Google a word mid-interview might not be the best idea, would it? Well, WordSense was created for these very situations. In what will eventually be ported to Apple Watch, WordSense will be able to define words in the moment, to your wrist, with a double tap of your fingers on Series 9 and Ultra 2 onwards. Sneak a peek at your wrist and save yourself from looking like a dum-dum: Welcome to WordSense.';
            let index = 0;

            showDialogButton.addEventListener('click', function () {
                dialogBox.style.opacity = '1';
                dialogBox.classList.remove('hidden');
                typeText();
            });

            closeButton.addEventListener('click', function () {
                dialogBox.style.opacity = '0';
                setTimeout(() => {
                    dialogBox.classList.add('hidden');
                }, 500);
            });

            function typeText() {
                if (index < text.length) {
                    textElement.innerHTML += text.charAt(index);
                    index++;
                    setTimeout(typeText, 50);
                }
            }
        });

        async function startListening() {
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.interimResults = false;
            recognition.continuous = true;

            recognition.onresult = async function (event) {
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        const finalizedWords = event.results[i][0].transcript.trim().split(" ");
                        lastWordTimestamp = Date.now();
                        wordBuffer = wordBuffer.concat(finalizedWords);
                        await processBufferedWords();
                    }
                }
            };

            recognition.onend = () => {
                document.getElementById('recordingButton').textContent = 'ðŸŽ™ Start Recording';
            };

            recognition.start();
            document.getElementById("notifyButton").disabled = false;
            document.getElementById("realTimeNotifyButton").disabled = false;
        }

        async function processBufferedWords() {
            while (wordBuffer.length > 0) {
                const word = wordBuffer.shift();
                const cleanWord = stripPunctuation(word);

                if (!definedWords.has(cleanWord)) {
                    const lemmaData = await extractLemma(cleanWord);
                    const lemma = lemmaData.result;

                    if (lemma) {
                        const frequency = await fetchWordFrequency(lemma);

                        if (frequency && frequency < frequencyThreshold) {
                            const originalWordDefinition = await fetchDefinition(cleanWord);

                            if (originalWordDefinition) {
                                definedWords.add(cleanWord);
                                appendToResults(word, true);
                                appendToDefinitionList(cleanWord, originalWordDefinition);
                                if (realTimeNotify) {
                                    new Notification(word, { body: originalWordDefinition });
                                }
                            } else {
                                appendToResults(word, false);
                            }
                        } else {
                            appendToResults(word, false);
                        }
                    } else {
                        appendToResults(word, false);
                    }
                } else {
                    appendToResults(word, false);
                }
            }
        }

        async function fetchWordFrequency(word) {
            try {
                const url = 'https://wordsapiv1.p.rapidapi.com/words/hatchback/typeOf';
                const options = {
	            method: 'GET',
	            headers: {
		            'X-RapidAPI-Key': 'e7d53037c6mshc2f7dbdae749571p103023jsneceda3961ddb',
		            'X-RapidAPI-Host': 'wordsapiv1.p.rapidapi.com'
                    },
                });

                if (response.status === 200) {
                    const data = await response.json();
                    return data.frequency || null;
                } else {
                    console.error('Failed to fetch word frequency.');
                    return null;
                }
            } catch (error) {
                console.error(error);
                return null;
            }
        }

        async function extractLemma(word) {
            const url = 'https://twinword-lemmatizer1.p.rapidapi.com/extract/';
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-RapidAPI-Key': 'e7d53037c6mshc2f7dbdae749571p103023jsneceda3961ddb',
                    'X-RapidAPI-Host': 'twinword-lemmatizer1.p.rapidapi.com'
                },
                body: new URLSearchParams({
                    text: word
                })
            };

            try {
                const response = await fetch(url, options);
                const result = await response.json();
                return result;
            } catch (error) {
                console.error(error);
                return null;
            }
        }

        async function fetchDefinition(word) {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en_US/${word}`);
            const data = await response.json();
            return data[0]?.meanings[0]?.definitions[0]?.definition || null;
        }

        function appendToResults(word, isUncommon) {
            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML += isUncommon ? `<span class="uncommon">${word}</span> ` : `${word} `;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function sendNotification() {
            if (Date.now() - lastWordTimestamp <= 10000) {
                definedWords.forEach(word => {
                    fetchDefinition(word).then(definition => {
                        if (definition) {
                            new Notification(capitalizeFirstLetter(word), { body: definition });
                        }
                    });
                });
            }
        }

        function toggleRealTimeNotifications() {
            realTimeNotify = !realTimeNotify;
            document.getElementById("realTimeNotifyButton").textContent = realTimeNotify ? 'Disable Real-time Notify' : 'Enable Real-time Notify';
        }
    </script>
</body>
</html>
